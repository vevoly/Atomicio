## 千万-亿级别的无状态架构
```mermaid
graph TD
    subgraph "Clients"
        Client1[...]
        Client2[...]
    end

    subgraph "Stateless Gateway Cluster (Your Atomicio Engine)"
        direction LR
        Node1[Atomicio Node 1]
        Node2[Atomicio Node 2]
        Node3[Atomicio Node ...]
    end
    
    subgraph "Distributed State & Routing Services"
        Registry[<b>Session Registry Service</b><br> e.g., Redis Cluster, ZK]
        GroupSvc[<b>Group Service</b><br> 管理群组成员]
        RouterSvc[<b>Message Router Service</b><br> 智能路由]
    end
    
    subgraph "Backend Business Services"
        UserSvc[User Service]
        OfflineSvc[Offline Message Service]
    end

    Client1 --> Node1
    Client2 --> Node2
    
    Node1 -- "Login: 注册会话<br>(userA -> node1)" --> Registry;
    Node2 -- "Login: 注册会话<br>(userB -> node2)" --> Registry;
    
    Node1 -- "发送消息 (to: userB)" --> RouterSvc;
    RouterSvc -- "1. 查询 B 在哪？" --> Registry;
    Registry -- "2. B 在 Node 2" --> RouterSvc;
    RouterSvc -- "3. 精准投递" --> Node2;
    Node2 --> Client2;

    Node1 -- "加入群组 (group1)" --> GroupSvc;
    Node1 -- "群发消息 (to: group1)" --> RouterSvc;
    RouterSvc -- "4. 查询 group1 成员" --> GroupSvc;
    GroupSvc -- "5. 返回成员列表 [A, B, C...]" --> RouterSvc;
    RouterSvc -- "6. 批量查询 A, B, C... 所在节点" --> Registry;
    RouterSvc -- "7. 分组批量投递" --> Node1;
    RouterSvc -- "7. 分组批量投递" --> Node2;
```

继续完善当前的“简单集群”模型:
把 bindUser 的多端登录配置化做好。
把心跳、重连等机制彻底打磨好。
让 CodecProvider 体系成熟起来。
目标: 发布一个强大的 v1.0 版本，它基于 Redis Pub/Sub，是一个开箱即用的、高性能的“分布式 IO 引擎”。
在文档中明确架构的边界:
在我们的架构文档中，明确指出：当前的集群模型适用于 X 级别的并发。对于千万级的超大规模部署，Atomicio 需要与外部的状态/路由服务集成，并提供相应的扩展接口。
为“无状态”演进预留接口:
我们可以提前在 api 模块中设计一些“未来”的接口，比如 SessionRegistryProvider, GroupServiceProvider。
DefaultAtomicIOEngine 的默认实现，可以使用一个**“In-Memory” (基于 Map) 的实现**。
这样，未来高级用户就可以通过 Spring 替换掉这些默认实现，插入一个与外部 Redis Cluster 或 Zookeeper 对接的实现，而无需修改 Atomicio 的核心代码。