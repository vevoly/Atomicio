### 协议无关的集群消息转发机制

```mermaid
graph TD
    subgraph "服务器节点 A (源节点)"
        A[MyMessageListener] -- "1. engine.sendToUser('B', normalMessage)" --> B(DefaultAtomicIOEngine);
        B -- "2. 发现 'B' 不在本地" --> C{encodeMessageTo BytesnormalMessage};
        C -- "3. 使用 ProtobufCodecProvider" --> D[内存中的临时 Pipeline<br> 只含 ProtobufEncoder 等];
        D -- "4. 输出 finalPayload (byte[])" --> C;
        C -- "5. 返回 finalPayload" --> B;
        B -- "6. buildClusterMessage(finalPayload)" --> E[ClusterMessage POJO];
        B -- "7. clusterManager.publish(pojo)" --> F(ClusterManager);
        F -- "8. Kryo 序列化 POJO" --> G[Kryo'd byte ];
        F -- "9. provider.publish(bytes)" --> H(RedisClusterProvider);
    end

    subgraph "消息中间件"
        H --> I[Redis Pub/Sub];
    end

    subgraph "服务器节点 B (目标节点)"
        J(RedisClusterProvider) -- "10. 收到 Kryo'd byte[]" --> K(ClusterManager);
        K -- "11. Kryo 反序列化" --> L[ClusterMessage POJO];
        K -- "12. publishClusterEvent(pojo)" --> M(Disruptor);
        M -- "13. 异步处理" --> N(DisruptorEventHandler);
        N -- "14. handleClusterMessage(pojo)" --> O{创建 RawBytesMessage};
        O -- "15. 包含 finalPayload" --> N;
        N -- "16. engine.sendToUserLocally('B', rawMessage)" --> P(SessionManager);
        P -- "17. session_B.send(rawMessage)" --> Q[Channel Pipeline 出站];
    end

    subgraph "节点 B 的出站 Pipeline"
        direction BT
        S[RawBytesMessageHandler] -- "18. **拦截** RawBytesMessage" --> Q;
        S -- "19. 直接写入 finalPayload (ByteBuf)" --> T(SSL Handler);
        U[ProtobufEncoder] -- "20. **被跳过** (类型不匹配)" --> S;
        T -- "21. 加密" --> V(网络);
    end

    style C fill:#ffe6cc
    style F fill:#d5e8d4
    style O fill:#cde4ff
    style S fill:#ffcdd2
```

1. 打包 (服务器 A):
   * Engine 收到发送请求后，调用 encodeMessageToBytes，利用当前节点的 CodecProvider (比如 ProtobufCodecProvider) 在一个内存 Pipeline 中，将 AtomicIOMessage “预编码”成最终要发送到网络上的二进制形态 finalPayload。
   * 然后，它将这个 finalPayload 连同路由元数据，一起打包成一个 ClusterMessage POJO。
   * ClusterManager 使用 Kryo (与上层协议无关的二进制序列化) 将这个 POJO 打包成最终的 byte[]，发往 Redis。
2. 中转 (Redis):
   * Redis 只是一个“字节搬运工”，它完全不知道自己传输的是什么内容。
3. 拆包与投递 (服务器 B):
   * ClusterManager 收到字节，用 Kryo 反序列化出 ClusterMessage POJO。
   * DisruptorEventHandler 从 POJO 中取出 finalPayload，并将其包装成一个特殊的 RawBytesMessage。这个 RawBytesMessage 就像一个贴着“VIP-免检”标签的包裹。
   * SessionManager 调用 session.send() 发送这个“VIP 包裹”。
4. 绿色通道 (节点 B 的 Pipeline):
   * 当“VIP 包裹” (RawBytesMessage) 在 Pipeline 中向上流动时，我们新加的 RawBytesMessageHandler 会识别并拦截它。
   * 它直接拆开包裹，将里面的 finalPayload (已经是最终的二进制形态) 写入 ByteBuf，然后传递给下一站（比如 SslHandler）。
5. 后续的常规编码器（ProtobufEncoder）因为不认识 RawBytesMessage (或者 RawBytesMessageHandler 已经把消息变成了 ByteBuf) 而被优雅地跳过。
6. 消息最终被成功发送。