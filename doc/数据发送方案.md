## 数据发送（路由）方案

### 数据路由设计

```mermaid
graph TD
    subgraph "客户端 (Client App)"
        A[<b>业务逻辑</b><br>e.g., ChatService]
        B[<b>AtomicIOClient</b> SDK]
        C[<b>CodecProvider</b>]
    end

    subgraph "服务器端 (Server)"
        D[<b>FrameworkCommandDispatcher</b>]
        E[<b>AtomicIOEngine</b>]
        F[<b>MyMessageListener</b><br>业务逻辑]
    end

    subgraph "协议定义 (Proto Files)"
        G[<b>框架 Proto</b><br>ForwardRequest, PushMessage]
        H[<b>业务 Proto</b><br>TextChatMessage, ImageMessage]
    end

    A -- "1. 调用 client.sendToUser(toId, bizPayload)" --> B
    B -- "2. 调用 codecProvider.createRequest(...)" --> C
    C -- "3. 创建 ForwardRequest (内含 bizPayload)" --> B
    B -- "4. 发送<br><b>SEND_TO_USERS</b>" --> D
    
    D -- "5. 解析 ForwardRequest" --> D
    D -- "6. 构建 PushMessage" --> D
    D -- "7. 调用 engine.sendToUsers(...)" --> E
    E -- "8. 路由并发送<br><b>PUSH_MESSAGE</b>" --> I[目标客户端]

    I -- "9. onPushMessage 触发" --> J[客户端业务逻辑]
    J -- "10. switch(bizPayloadType)" --> J
    J -- "11. 解析出 TextChatMessage" --> J
```

```mermaid
sequenceDiagram
    participant AppA as App A (业务)
    participant SdkA as Client SDK A
    participant Server as 服务器 (框架)
    participant SdkB as Client SDK B
    participant AppB as App B (业务)

    AppA->>+SdkA: sendToUser("userB", bizMsg)

    Note over SdkA, Server: (1) 包装成 ForwardRequest (cmd=SEND_TO_USERS)
    SdkA->>+Server: 发送 SEND_TO_USERS
    Server-->>-SdkA: (2) 网络投递成功 (CompletableFuture 完成)

    Note over Server: (3) 解析出 bizMsg, 路由给 B
    Server->>+SdkB: 发送 PUSH_MESSAGE

    Note over SdkB, AppB: (4) onPushMessage 触发
    SdkB->>+AppB: onPushMessage(pushMsg)

    Note over AppB: (5) 业务逻辑处理 bizMsg... 成功！
    AppB->>+SdkB: sendAck("userA", client_msg_id)

    Note over SdkB, Server: (6) 包装成 ForwardRequest (内含 P2PMessageAck, cmd=SEND_TO_USERS)
    SdkB->>+Server: 发送 SEND_TO_USERS
    Server-->>-SdkB: (7) 网络投递成功 (CompletableFuture 完成)

    Note over Server: (8) 解析出 P2PMessageAck, 路由给 A
    Server->>+SdkA: 发送 PUSH_MESSAGE

    Note over SdkA, AppA: (9) onPushMessage 触发
    SdkA->>+AppA: onPushMessage(pushMsg)

    Note over AppA: (10) 解析出 P2PMessageAck, 更新UI为“已送达” 
    
     
```

### 消息群发设计
#### 流程:
1. engine.sendToUsers(["user1", "user2", ...], msg) -> 节点X 发现这些用户分布在 A, B, C 三个节点。
2. 它将这些用户按所在节点进行分组：
   * Node A: ["user1"]
   * Node B: ["user2", "user3"]
   * Node C: ["user4"]
3. 然后，它为每个目标节点只发送一条批量集群消息：
   * -> 节点A: BatchClusterMessage(to=["user1"], payload=msg)
   * -> 节点B: BatchClusterMessage(to=["user2", "user3"], payload=msg)
   * -> 节点C: BatchClusterMessage(to=["user4"], payload=msg)
4. 目标节点（如节点B）收到 BatchClusterMessage 后，在本地进行循环，将消息分发给 user2 和 user3。
#### 资源消耗:
* Redis Pub/Sub: 只发布了 3 条消息（因为只有3个目标节点）。
* Kryo 序列化/反序列化: 只执行了 3 次。
* 网络传输: 只产生了 3 次网络数据包。
#### 优点:
1. 降低中间件压力: 当 userIds 列表非常大时（例如，给 10000 个用户发送通知，他们分布在 10 个节点上），循环发送会瞬间向 Redis 写入 10000 条消息，可能导致 Redis 阻塞。而批量方案只会写入 10 条消息。这是最核心的优势。
2. 减少网络 I/O: 减少了网络数据包的数量，降低了网络拥塞的可能性。
3. 降低序列化开销: message 本身（可能是个大对象）只需要被序列化 3 次，而不是 4 次。
4. 原子性更强: 目标节点一次性收到所有需要它处理的用户列表，便于进行事务性操作或日志记录。

### 集群精准投递
1. 全局广播的灾难:
* 节点A 向 Redis 的全局频道发布一条消息：“请把这个包裹转交给 userX”。
* 集群中所有的节点（A, B, C, D, ...）都会收到这条广播消息。
* 每个节点都必须在本地检查：“userX- 在我这里吗？”
* 最终，只有节点B 发现 userX 在本地，并进行投递。其他所有节点都做了无用功，白白浪费了 CPU 和网络资源。
2. 精准投递：
* userId -> nodeId 的映射，节点 A 可以直接查询得知 userX 在节点 B，然后只向节点 B 的专属频道发送一条消息，干净利落。
3. 维护 userId -> nodeId 映射关系：
* Hash 数据结构
  * key: atomicio:stats:user_nodes
  * field: userId
  * value: nodeId
* 职责划分
  * AtomicIOSessionStateProvider (接口): 负责定义**“注册”、“注销”和“查询”**这个全局映射的契约。
  * RedisSessionStateProvider (实现): 负责使用 HSET, HDEL, HGET, HMGET 等 Redis 命令来具体实现这些契约。