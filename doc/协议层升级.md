# 协议层升级

```mermaid
graph TD
    subgraph "atomicio-spring-boot-starter"
        A[application.yml] -- "atomicio.codec.type=protobuf" --> B(AutoConfiguration)
    end

    subgraph "Spring IoC 容器"
        B -- "1. 根据 'protobuf' 创建" --> C(ProtobufCodecProvider);
        C -- "2. 注入到" --> D(DefaultAtomicIOEngine);
    end

    subgraph "atomicio-core"
        D -- "3. 在启动时使用" --> E(ChannelPipeline);
    end
    
    subgraph "ChannelPipeline 内部"
        direction LR
        E --> F[ProtobufDecoder];
        F --> G[ProtobufEncoder];
        G --> H[EngineChannelHandler];
    end

    subgraph "Codec 模块 (插件)"
        C_Proto(atomicio-codec-protobuf.jar)
        C_Text(atomicio-codec-text.jar)
        C_Mqtt(atomicio-codec-mqtt.jar)
    end
    
    style B fill:#d5e8d4
    style C fill:#ffe6cc
    style D fill:#cde4ff
```
```mermaid
sequenceDiagram
    participant Client
    participant Netty_IO_Thread
    participant FrameDecoder as "帧解码器 (可选, e.g., LengthFieldBasedFrameDecoder)"
    participant ProtobufDecoder as "ProtobufDecoder (from Provider)"
    participant EngineChannelHandler
    participant ProtobufEncoder as "ProtobufEncoder (from Provider)"

    Note over Client, Netty_IO_Thread: === 消息上行 (Inbound) ===
    Client->>+Netty_IO_Thread: 发送 Protobuf 字节流 (ByteBuf)

    Netty_IO_Thread->>+FrameDecoder: channelRead(ByteBuf)
    Note right of Netty_IO_Thread: 解决 TCP 粘包/半包问题
    FrameDecoder-->>-Netty_IO_Thread: (输出一个完整的消息包 ByteBuf)

    Netty_IO_Thread->>+ProtobufDecoder: channelRead(完整包 ByteBuf)
    Note right of Netty_IO_Thread: 将字节反序列化为 Protobuf 对象
    ProtobufDecoder-->>-Netty_IO_Thread: (输出 Protobuf Java 对象)

    Netty_IO_Thread->>+EngineChannelHandler: channelRead(Protobuf 对象)
    Note right of Netty_IO_Thread: **这里需要适配！** 将 Protobuf 对象<br>转换成我们通用的 AtomicIOMessage
    EngineChannelHandler->>EngineChannelHandler: (发布 MESSAGE 事件到 Disruptor)
EngineChannelHandler-->>-Netty_IO_Thread: 

Note over Client, Netty_IO_Thread: === 消息下行 (Outbound) ===
Netty_IO_Thread->>+ProtobufEncoder: ctx.write(AtomicIOMessage)
Note right of Netty_IO_Thread: 业务逻辑调用 session.send()
ProtobufEncoder->>ProtobufEncoder: (拦截 AtomicIOMessage, <br>将其转换成 Protobuf 对象后序列化)
ProtobufEncoder-->>-Netty_IO_Thread: (输出 ByteBuf)

Netty_IO_Thread-->>-Client: 发送 Protobuf 字节流
```

### 用户如何扩展 Protobuf ？
#### 1. 用户在自己的项目中，创建自己的 .proto 文件，例如 game.proto：
user-project/src/main/proto/game.proto
```protobuf
syntax = "proto3";

package com.mygame.proto;

option java_package = "com.mygame.proto";

message MyLoginRequest {
  string username = 1;
  string password = 2;
}

message MyPlayerMove {
  int32 x = 1;
  int32 y = 2;
}
```
#### 2. 用户的业务逻辑 (MyMessageListener)
```java
// 在用户的 MyMessageListener.java 中

@Override
public void onEvent(AtomicIOSession session, AtomicIOMessage message) {
    try {
        // 1. 将 AtomicIOMessage 的 payload 解码成 GenericMessage
        GenericMessage genericMsg = GenericMessage.parseFrom(message.getPayload());
        
        int commandId = genericMsg.getCommandId();
        google.protobuf.Any payload = genericMsg.getPayload();

        switch (commandId) {
            case CommandIds.LOGIN:
                // **关键：解包 Any**
                // is() 方法检查 Any 中包含的是否是 MyLoginRequest 类型
                if (payload.is(MyLoginRequest.class)) {
                    // unpack() 方法安全地将其解包
                    MyLoginRequest loginRequest = payload.unpack(MyLoginRequest.class);
                    handleLogin(session, loginRequest);
                }
                break;
            case CommandIds.PLAYER_MOVE:
                if (payload.is(MyPlayerMove.class)) {
                    MyPlayerMove moveRequest = payload.unpack(MyPlayerMove.class);
                    handlePlayerMove(session, moveRequest);
                }
                break;
        }
    } catch (InvalidProtocolBufferException e) {
        log.error("Failed to parse protobuf message", e);
        session.close();
    }
}

// 业务处理方法现在接收的是具体的、强类型的 Protobuf 对象
private void handleLogin(AtomicIOSession session, MyLoginRequest request) {
    // ...
}
```
#### 3. 客户端发送消息
```java
// 在客户端代码中
MyLoginRequest loginRequest = MyLoginRequest.newBuilder()
        .setUsername("test")
        .setPassword("123456")
        .build();

GenericMessage genericMsg = GenericMessage.newBuilder()
        .setCommandId(CommandIds.LOGIN)
        // **关键：打包 Any**
        .setPayload(com.google.protobuf.Any.pack(loginRequest))
        .build();

// 将 genericMsg 序列化后发送
byte[] dataToSend = genericMsg.toByteArray();
```

### Protobuf-example 架构图
```mermaid
graph TD
    subgraph "Spring Boot Application"
        A[ProtobufExampleApplication] -- "启动" --> B{Spring Context};
    end

    subgraph "atomicio-spring-boot-starter (自动化装配)"
        B -- "1. 读取 yml, 创建" --> C[AtomicIOProperties Bean];
        B -- "2. 根据配置创建" --> D[ProtobufCodecProvider Bean];
        B -- "3. 创建" --> E[AtomicIOEngine Bean <br> 注入 CodecProvider];
        B -- "4. 扫描并创建" --> F[MyMessageListener Bean];
        B -- "5. 创建" --> G[LifecycleManager Bean <br> 注入 Engine 和 Listeners];
    end

    subgraph "运行阶段"
        G -- "6. Spring 启动后, 调用" --> H{LifecycleManager.start};
        H -- "7. 注册所有 Listeners" --> E;
        H -- "8. 启动 Netty Server" --> E;
        I[Client] -- "9. Protobuf 连接" --> E;
    end

    subgraph "消息处理"
        E -- "10. 收到消息, 经 Disruptor" --> J{AtomicIOEventHandler};
        J -- "11. 调用 fireMessageEvent" --> E;
        E -- "12. 触发" --> F;
        F -- "13. 执行 handleP2PMessage" --> F;
        F -- "14. 调用" --> E_API(engine.sendToUser);
    end

    style A fill:#d5e8d4
    style B fill:#fff2cc
    style G fill:#ffcdd2
    style F fill:#cde4ff
```
### P2P 消息数据流转时序图
```mermaid
sequenceDiagram
    participant Client_A as 客户端 A
    participant Server_Node1 as 服务器节点1<br>(A连接在此)
    participant Redis_PubSub as Redis 集群总线
    participant Server_Node2 as 服务器节点2<br>(B连接在此)
    participant Client_B as 客户端 B

    Note over Client_A, Client_B: 假设 A 和 B 都已登录

    Client_A->>+Server_Node1: 1. 发送 P2PMessageRequest (to:B, content:"Hi", clientMsgId:"c123")
    Note right of Client_A: 消息状态: "发送中..."

    Server_Node1->>Server_Node1: 2. Pipeline 解码 -> MyMessageListener.onEvent()
    Server_Node1->>Server_Node1: 3. 执行 handleP2PMessage()
    
    Note right of Server_Node1: a) 生成 serverMsgId: "s456"

    Server_Node1-->>-Client_A: 4. **立即回复 ACK**<br>P2PMessageAck (clientMsgId:"c123", serverMsgId:"s456")
    Note right of Client_A: 收到ACK, 消息状态: "已送达 ✓"

    Note right of Server_Node1: b) 查找 toUserId:"B", 发现不在本地

    Server_Node1->>+Redis_PubSub: 5. **发布到集群**<br>ClusterMessage (to:B, from:A, content:"Hi", serverMsgId:"s456")
    
    Redis_PubSub-->>Server_Node1: 6a. (广播给自己，忽略)
    Redis_PubSub-->>-Server_Node2: 6b. **广播给节点2**

    Server_Node2->>Server_Node2: 7. RedisProvider 收到消息 -> handleClusterMessage()
    Server_Node2->>Server_Node2: 8. 调用 engine.sendToUserLocally("B", ...)
    
    Note right of Server_Node2: 查找 toUserId:"B", 发现**在本地**

    Server_Node2-->>+Client_B: 9. **转发消息通知**<br>P2PMessageNotify (from:A, content:"Hi", serverMsgId:"s456")
    Client_B-->>-Server_Node2: 
```
