## 混合驱动模型架构设计 0.6.5
### 核心演进对比
```mermaid
graph TD
    subgraph "当前版本 (v0.6.4): 纯事件驱动模式"
        A[Netty Channel] --> B{协议解码器};
        B --> C[NettyEventTranslationHandler];
        C --> D[DisruptorEventHandler];
        D --> E{AtomicIOEventManager};
        E --> F[<b> 用户侧 </b><br>MyMessageListener];
        subgraph "用户 Listener 职责"
            F -- 处理 --> G1[登录/认证<br><i> 调用 engine.bindUser</i>];
            F -- 处理 --> G2[登出<br><i> 调用 engine.kickUser </i>];
            F -- 处理 --> G3[加入/离开群组<br><i> 调用 engine.join/leaveGroup </i>];
            F -- 处理 --> G4[业务消息<br><i> P2P, Group Msg... </i>];
        end
    end

    subgraph "<b>演进目标 (v0.6.5): 混合驱动模式</b>"
        A2[Netty Channel] --> B2{协议解码器};
        B2 --> C2["<b>新增:</b><br>FrameworkCommandDispatcher"];
        subgraph "框架 Handler 职责"
            style C2 fill:#d4edda,stroke:#155724
            C2 -- 框架命令 --> H1[登录/认证<br><i> 回调用户 Authenticator, 内部调用 bindUser </i>];
            C2 -- 框架命令 --> H2[登出<br><i> 内部调用 unregister/kick </i>];
            C2 -- 框架命令 --> H3[加入/离开群组<br><i> 内部调用 join/leaveGroup </i>];
        end
        C2 -- 业务命令 --> D2[DisruptorEventHandler];
        D2 --> E2{AtomicIOEventManager};
        E2 --> F2[<b> 用户侧 </b><br>MyMessageListener];
        F2 -- 只处理 --> G5[业务消息<br><i> P2P, Group Msg... </i>];
    end

    style F fill:#f8d7da,stroke:#721c24
    style F2 fill:#cce5ff,stroke:#004085
```
### 混合驱动模式架构图
```mermaid
graph TD
    subgraph "用户空间 (User Space)"
        U1[业务代码<br>App Bootstrap]
        U2["<b>(需用户实现)</b><br>Authenticator 接口实现"]
        U3["<b>(简化后)</b><br>MessageEventListener 实现"]
    end

    subgraph "框架核心 (AtomicIO Core)"
        subgraph "API & 配置层"
            Engine[AtomicIOEngine]
            U1 -- 配置 --> Engine
            U1 -- 注册 --> U3
            Engine -- 注入 --> U2
        end

        subgraph "网络处理层 (Netty Pipeline)"
            A[Channel] --> Dec{协议解码器}
            Dec --> FCD{<b>FrameworkCommandDispatcher</b>}
            FCD -- 业务消息 --> DEH[DisruptorEventHandler]
            DEH --> AEM[AtomicIOEventManager]
            AEM --> U3
        end
        
        subgraph "核心管理器 (Managers)"
            SM[AtomicIOStateManager]
            SessM[AtomicIOSessionManager]
            GM[AtomicIOGroupManager]
            CM[AtomicIOClusterManager]
        end
    end

    %% 关系连线
    FCD -- 框架命令 --> Engine
    Engine -- 委托 --> SM
    Engine -- 委托 --> SessM
    Engine -- 委托 --> GM
    Engine -- 委托 --> CM
    
    SM -- 依赖 --> SessM & GM & CM
```
* FrameworkCommandDispatcher 成为网络层的第一道关卡。它像一个智能路由器，根据 CommandId 对消息进行分流。
* 框架命令流: Dispatcher 识别出登录、登出等框架命令后，会直接调用 AtomicIOEngine 的内部方法，这些方法再委托给相应的 Manager (StateManager, SessionManager等) 来执行核心逻辑。
* 业务命令流: Dispatcher 识别出是业务命令后，会像以前一样，将消息传递给 DisruptorEventHandler，最终触发用户注册的 MessageEventListener。
* 认证回调: Engine 提供了一个方法（如 setAuthenticator）让用户注入一个 Authenticator 实现。当 Dispatcher 收到登录请求时，会通过 Engine 回调这个用户的认证逻辑，从而实现了框架逻辑和业务认证逻辑的解耦。

### 数据流转时序图
```mermaid
sequenceDiagram
    participant C as Client
    participant N as Netty Server
    participant FCD as FrameworkCommandDispatcher
    participant Auth as <b>(用户)</b> Authenticator
    participant Engine as AtomicIOEngine
    participant SM as AtomicIOStateManager
    participant SessM as AtomicIOSessionManager

    C->>+N: 发送登录请求 (LOGIN_REQUEST)
    N->>FCD: 收到解码后的 AtomicIOMessage
    
    FCD->>FCD: 检查 CommandId == LOGIN_REQUEST
    
    Note over FCD, Auth: Dispatcher 通过 Engine 回调用户注入的认证器
    FCD->>+Engine: authenticate(request)
    Engine->>+Auth: verify(credentials)
    Auth-->>-Engine: 认证成功
    
    alt 认证成功
        Engine-->>-FCD: 返回认证结果(成功)
        Note over FCD, SM: 认证通过，框架自动执行绑定流程
        FCD->>+Engine: internalBindUser(request, session)
        Engine->>+SM: register(bindRequest, isMultiLogin)
        SM->>SM: (处理多端登录冲突、踢人等...)
        SM-->>-Engine: 注册完成
        
        Engine->>+SessM: addLocalSession(session)
        SessM-->>-Engine: 绑定成功
        Engine-->>-FCD: 绑定操作完成
        
        Note over FCD, C: 框架自动发送登录成功响应
        FCD->>N: 构造 LOGIN_RESPONSE (Success)
        N-->>-C: 发送登录响应
    else 认证失败
%%        Engine-->>-FCD: 返回认证结果(失败)
%%        Note over FCD, C: 框架自动发送登录失败响应并关闭连接
%%        FCD->>N: 构造 LOGIN_RESPONSE (Failed)
%%        N-->>-C: 发送登录响应
        N->>N: close()
    end
```
1. 客户端发送登录请求。
2. FrameworkCommandDispatcher 截获该请求。
3. Dispatcher 不直接处理业务认证，而是通过 Engine 调用已注册的用户Authenticator。
4. 用户Authenticator 返回认证结果。
5. 如果成功，Dispatcher 自动调用 Engine 的内部绑定方法，触发 StateManager 和 SessionManager 的一系列核心操作。
6. 所有框架层面的状态更新完成后，Dispatcher 自动给客户端回复一个标准的 LOGIN_RESPONSE。
7. 在这个过程中，用户的 MessageEventListener 完全没有被调用，登录流程对业务代码完全透明。

### 入站数据流转图
```mermaid
graph TD
    subgraph "网络层 (Netty)"
        A[网络字节流 Inbound]
    end

    subgraph "协议解码层 (Pipeline: Part 1)"
        B_Proto{ProtobufDecoder}
        B_Text{TextDecoder}
        B_Json{JsonDecoder}
    end

    subgraph "框架核心处理层 (Pipeline: Part 2)"
        C[<b>FrameworkCommandDispatcher</b>]
    end

    subgraph "业务逻辑层 (Pipeline: Part 3)"
        D[DisruptorEventHandler] --> E[用户 MessageEventListener]
    end

    A --> B_Proto
    A --> B_Text
    A --> B_Json

    B_Proto -- "输出 ProtobufMessage 对象" --> C
    B_Text -- "输出 TextMessage 对象" --> C
    B_Json -- "输出 JsonMessage 对象" --> C

    C -- "识别为框架命令<br>(e.g., LOGIN_REQUEST)" --> F1[直接处理并响应]
    C -- "识别为业务命令" --> D
```